<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Minimal</title>
    <link>/</link>
    <description>Recent content on Minimal</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 24 Mar 2019 13:57:37 +0000</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>实现Lua-AST</title>
      <link>/blog/posts/implement-lua-ast/</link>
      <pubDate>Sun, 24 Mar 2019 13:57:37 +0000</pubDate>
      
      <guid>/blog/posts/implement-lua-ast/</guid>
      <description>实现Lua解释器-AST 调研 最近终于开始做毕设了，于是开始考虑是否用一款语法分析生成器来写Lua前端，遂发现Pest, 一款Rust的语法分析器，使用PEG文法。这个文法有点像BNF和正则的融合，但是定义无歧义，表达能力小于等于CFG。写起来比较舒服，考虑到Lua官方文法整理出来有许多左递归文法，改写很麻烦（我不太会），虽然Pest本身编写很友好，但是感觉文档描述有点少，有些关键的地方使用不清楚，加上没有IDE的代码提示，遂放弃（不过写一些小语言的简单文法以后可以考虑）。之前用过Nom这款解析组合子库，这个库性能非常好，但是我觉得语法设计的非常怪异，之前用也没搞清楚，对于之前编写的某个玩具虚拟机的字节码编译器使用起来也是小题大做，反而搞复杂了。
于是乎，还是打算手写。考虑到Lua本身文法少，手写代码量不会多上几百行；自己之前也没有实现一个比较满意的解析器；如果用语法生成生成器，首先还得学，然后得花时间改写文法，有点得不偿失。
词法 首先随便写了点词法这块，发现我抽象能力太弱了，本来想多用第三方库实现更抽象性能更好的词法分析类，但我有点不太熟悉泛型编程，而且前期具体工作不明确，写了很大概率后面要改。于是乎，就是很粗糙地使用了String类型。而对于具体的词法分析，感觉写过很多次，每次套路都写的不一样，参考别人的实现，也都是五花八门，我也没法判断哪种够优雅。而对于Lua语言，毕竟是工业级语言，词法分析实现细节一定要参考书或官方文档，语法细节非常多。
先从AST开始 果然了解一门语言除了常见的语法特性见识了以外，看文法和AST感觉也不错。不过我个人对文法不太感兴趣，也不太擅长，而AST可以看清楚这个语言的很多语义。 下面整理一下Lua的AST，可能设计的一般般，以后肯定还需要改动。下面我只列出AST，而不写出文法。
#[derive(Debug)] pub struct Block { last_line: Line, stats: Vec&amp;lt;Stat&amp;gt;, ret_exps: Vec&amp;lt;Exp&amp;gt;, }  Block，或 Chunk，是Lua最小编译单位。Lua解释器通过传递Block给编译器，生成字节码后解释执行。Block必须包含语句和返回值，当然返回值可以有多个，而且可以是表达式，这个很自然。
接下来的 Stat有点长，它表示Lua的语句(statment)。语句包括了表达式(expression)的结构，这跟许多静态语言不一样所以会比较长，但这也是它的主体了。 仔细一看，Stat也只有几个流程控制，赋值（包括变量定义），函数定义，无他。写过一点lua就知道，lua没有哪些地方的代码需要提升(lift)，都是在解释时进入到环境的。
#[derive(Debug)] pub enum Stat { Empty, Break { line: Line, }, Label { name: String, }, Goto { name: String, }, Do { block: Box&amp;lt;Block&amp;gt;, }, While { exp: Exp, block: Box&amp;lt;Block&amp;gt;, }, Repeat { exp: Exp, block: Box&amp;lt;Block&amp;gt;, }, If { exps: Vec&amp;lt;Exp&amp;gt;, blocks: Vec&amp;lt;Block&amp;gt;, }, ForNum { line_of_for: Line, line_of_do: Line, var_name: String, exps: (Exp, Exp, Exp), block: Box&amp;lt;Block&amp;gt;, }, ForIn { line_of_do: Line, name_list: Vec&amp;lt;String&amp;gt;, exp_list: Vec&amp;lt;Exp&amp;gt;, block: Box&amp;lt;Block&amp;gt;, }, LocalVarDecl { last_line: Line, name_list: Vec&amp;lt;String&amp;gt;, exp_list: Vec&amp;lt;Exp&amp;gt;, }, Assign { last_line: Line, var_list: Vec&amp;lt;Exp&amp;gt;, exp_list: Vec&amp;lt;Exp&amp;gt;, }, LocalFnDef { name: String, exp: Box&amp;lt;Exp&amp;gt;, }, }  写到这里，说实话好像讲AST没什么意思，于是下面这个也没什么好总结了。不过要注意好一些值的限定，虽然有些地方使用了Exp，但是其实里面用的枚举值是固定的， 其实可以提出来单独定义。我为了整体的简洁性，就没这样做。在后面的实现中，应该对性能和代码量有一定影响，不过到时候改也不迟。 这里有个不好的地方就是Line几乎都用到了，为什么不封装一下呢？主要是还是为了简单而多了样板代码，到后期写的时候不会因为类型过多而处理麻烦。</description>
    </item>
    
    <item>
      <title>About Me</title>
      <link>/about/</link>
      <pubDate>Thu, 21 Feb 2019 19:00:24 +0000</pubDate>
      
      <guid>/about/</guid>
      <description>About Me 已经毕业
Contract  手机号：15968857843 Email：465402634@qq.com / yjh465402634@gmail.com QQ：465402634  Personal Information  姓名：叶家豪 学校：杭州电子科技大学 教育：本科 专业：计算机科学与技术 本科毕业：2019年7月 Blog: https://yjhmelody.github.io/ Github: https://github.com/yjhmelody  Experiences  2018年美国大学生数学建模竞赛 一等奖 证书 2018年第九届全国服务外包创新大赛 三等奖 海量数据存储课程大作业：编写爬虫爬取了全网链接和Wiki站内链接，并使用 Scala 和 Spark 编写PageRank 算法分别进行网页排名 数据挖掘课程大作业，简单的电影推荐系统：协调和对接各个组员的模块，主要实现了爬虫和数据库查询部分。 参与计算机学院 MIL 实验室的暑期机器学习项目 用 JS 编写简单的类 Lisp 语言的解释器。 参与 Nodejs 中文文档的翻译  Interests  工程：对计算机系统知识有一定的兴趣，比如计算机体系结构，编程语言虚拟机，数据库系统。 理论：对编程语言理论和编译原理有一定的兴趣。  近期期望学习的内容：
 计算机科学相关的数学基础(抽象代数，数理逻辑) 编程语言理论(PLT) 数据库原理/分布式原理 初级日语  Professional Skills 部分专业课：
 离散数学 数据结构 算法分析与设计 计算机图形学 计算机组成原理 软件工程 操作系统 编译原理 计算机网络 计算机系统结构 计算方法 数字图像处理 数据挖掘 海量数据存储 云计算技术  习惯的开发环境：</description>
    </item>
    
    <item>
      <title>2018年总结和未来展望</title>
      <link>/blog/posts/2018%E5%B9%B4%E6%80%BB%E7%BB%93%E5%92%8C%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B/</link>
      <pubDate>Mon, 31 Dec 2018 16:18:37 +0000</pubDate>
      
      <guid>/blog/posts/2018%E5%B9%B4%E6%80%BB%E7%BB%93%E5%92%8C%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B/</guid>
      <description>昨天是我的公历生日，本作为总结2018这年的大好日子，可惜拖延症犯了，把博客一些地方小改一下就作罢了。
考研迷思 虽然备考途中，多次心情波动，懒癌和睡眠等问题，几乎要放弃考研了，甚至有次备考资料丢失，还是多亏周围的同学对我的鼓励和支持，最后也算勉勉强强上道了。 最后几天几乎也没法提升水平了，只好不停地看错题，记忆一些生僻的公式，翻翻书把近几年不常考的知识点也巩固下。那时候想着，只要好好发挥，不要再在计算上犯错就应该能够达成目标。
考研前到考研结束的那10天，几乎是我最放松的几天。这让想起来了高考，最后一个月也是这般，因为清楚的认识到自己的能力和短期的可能性，变得不会盲目地学习，而是以考研也是生活中的一部分这样的处事态度来度过。所以我每天照样追番，照样看其他感兴趣的领域知识，我觉得人生不过如此了。如果把目光聚焦于当前，“考研失败”，“失业”，“感染疾病”，“单身一辈子”，“没有朋友”等这些人们口中常道的事物都让我不觉得可怕。
不过我还是对一个里程碑式的事件的结束所产生的环境影响、人际影响和社会影响大意了。如果说考研时候周围大部分人与你是同一战线，那结束后，人们往往更容易走向对立面。当我对考研时人们相互鼓励而记忆犹新之时，周围人对同一件事物的分歧在考研结束后完全暴露出来了。在此我不具体展示讲述这些矛盾的变化，只总结一下，人们对同一事物产生的不同焦虑的原因。
拿我自己来讲，我只是个喜欢意淫美好生活，偶尔为之奋斗的人罢了。可能在别人眼里我也勉强算个理想主义者，不过目前还未闻有人如此道之。我也不太了解别人是如何评价我的，我这样的性格决定了我面对一件事情的时候，不太喜欢做评价（对好坏的事件均保留积极和消极的看法）。如果其他人过于消极或积极，我倾向于调和他的极端的想法。所以考研的时候，我自己虽然有自己一套协调的方法论，但自己仍然有许多焦虑，最后10多天才看开了。不过其他同学，大多数都持有消极的情绪，当我遇见他们时，总是设法通过谈话让他们积极点，虽然目前周围人总是该怎么做还是怎么做，什么样的三观，什么的方法论，什么的处事原则，在我看来并没有改变。
他们说自己考研是为了更好的学历，更好的工作，更好的发展。虽然我理解，但我总是像个乡巴佬一样想不明白————既然只是为了更好的东西，而从未明显表现对现状的不满（该打游戏还是打，整天吃喝玩乐还是吃喝玩乐，吃饭总要一起约的人，还有说有笑的，哪里看得出不幸福？），那么所谓的现状为何要在明面上要遭人唾弃，这让我想起来了“政治正确”这个东西。
那么他们焦虑的源头哪里来的？我稍作了思考还通过和一些同学的交流来总结。可能的原因是： 1. 他们作为人，却无法独立。许多东西的价值要依托于人，才能发挥出来。拿考研来说，他们的主体不是自我，而是目标院校、家庭、优越的工作等（我不是说这些不重要，我强调的是人首先得重视自我本身，而不是被他人要求的自我）。脱离人肯定会产生焦虑和不安，但过分依赖也一样会因为波动而产生焦虑。我个人自己也在往看淡这些而努力中。 2. 理想、物质等方面作为指导和追求，绑架了人本身。人们开始不经过思考还追逐东西，我觉得这是物化的表现，即非生物的一般物质的运动（首先表明我坚持唯物观点）。玩梗的话就是说“还没思考，身体已经动了起来”。当年“大妈”争相抢购大甩卖的商品这样的现象，如今在更广泛的群体中以更隐蔽的方式表现出来。最后人追求幸福变成了追求固化的，物化的事物，在人们眼里太具体了，以至于像物质的运动一般，眼光像光线一样直直地发射出来。我还记得以前考试的作文，“孩子的眼光是直的，不会转弯”，如今看来孩子的思维虽然也是直的，不过倒是比许多人深邃多了，着实让人捉摸不透。
笔可能要峰回路转了，才想起应该写的是总结。
对18年道声谢 18年看过心理老师，18年焦虑过非常多次，18年参加过2次比赛，18年准备了半年考研，18年还看过许多书，18年下了两场雪，18年末尾还投了2个简历，18年父母又开店工作了。
18年我才知道我其实对很多甚至不局限于计算机的知识感兴趣，虽然一直没有学好相关知识，不过应该能保持学习热情。
对19年展望 目前考研水平未知，我自己是不感兴趣也不喜欢校对考试答案的。所以在可能考上这个前提下，准备找份实习，如果考研失败，则实习转正或者继续找新的公司（当然目前还没有开始面试公司）。毕设选了一个很有挑战的题目，所以我也蛮忐忑的，他们总说为什么不选个简单的，现在想来我不应该那样回答他们。目前打算把最后一个作业赶紧完成，之后整理下19年想看的书目，为自己安排一个合理的学习时间。如果有机会去北京（实习需要，考研成功等），我想去清华和北大感受下，可能的话还想去天安门和长城。工作相关，我其实一直是抛开像简历那样具体的东西的，总体上我其实想做计算机基础设施相关的研究或者工程。
可能许多同学虽然在别人眼里已经是前程似锦，不过似乎他们也有难言之痛，似乎活在当下必要受到煎熬。我没有经历过大风大浪，只觉得生活依然美好。</description>
    </item>
    
    <item>
      <title>《DDIA》概念整理</title>
      <link>/blog/posts/ddia%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/</link>
      <pubDate>Thu, 30 Aug 2018 20:00:00 +0000</pubDate>
      
      <guid>/blog/posts/ddia%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/</guid>
      <description>最近指忙里抽闲的看《Designing Data-Intensive Applications》（《设计数据密集型应用》）这本书，主要书看中文为主。这本书非常好，我现在刚看完一半。这本书让你认识到了数据库系统和分布式系统的大概貌，没有深入繁琐的具体细节也没有让人浅尝辄止。这本书网络上评价很高，甚至豆瓣评分有2个评分，一个是9.5分，一个是10分。现在即使想作为一个普通的后端工程师也需要学习分布式知识了，强烈推荐这本书。
我发现书后面的术语表非常精良，个人认为：虽然可能还涵盖不到一半的核心概念，但是如果能深刻的理解这术语表部分的，那对数据库系统和分布式系统就有了比较好的整体认识了。
顺便，光看这本书就需要接触过数据结构，操作系统，计算机网络，数据库原理，还有少部分组成原理的知识，不然只能知其然不知其所以然。限于自己的个人水平和这方面不多的实践，有些部分还没有理解到位。个人认为，学习分布式可能还需要学习一点并行编程和网络编程，分布式系统可能是综合性比较强的方向了。并且根据具体要做的分布式系统，可能还需要机器学习，搜索引擎等知识。
这本书配合着学习 MIT6.824 可能会非常好吧。
以下整理出了英文和中文的术语表。
英文 asynchronous Not waiting for something to complete (e.g., sending data over the network to another node), and not making any assumptions about how long it is going to take. See Synchronous Versus Asynchronous Replication on page 153, Synchronous Versus Asynchronous Networks on page 284, and System Model and Reality on page 306.
atomic  In the context of concurrent operations:describing an operation that appears to take effect at a single point in time, so another concurrent process can never encounter the operation in a halffinished state.</description>
    </item>
    
    <item>
      <title>记小时候一些事情</title>
      <link>/blog/posts/%E8%AE%B0%E5%B0%8F%E6%97%B6%E5%80%99%E4%B8%80%E4%BA%9B%E4%BA%8B%E6%83%85/</link>
      <pubDate>Fri, 27 Jul 2018 21:56:20 +0000</pubDate>
      
      <guid>/blog/posts/%E8%AE%B0%E5%B0%8F%E6%97%B6%E5%80%99%E4%B8%80%E4%BA%9B%E4%BA%8B%E6%83%85/</guid>
      <description>我喜欢当别人的聆听者，也喜欢讲故事和观点给别人听，如果很久很久没有这样做，我大概是已经疯掉了吧。以下都是自己的碎碎念，不必在意。
小学的时候，迷上了一款游戏（当然，其实玩过很多游戏），那时候还把两个玩伴带到坑里来。这一起一玩就是5年，后来我偶尔还会上线过，如今上了大学仍然不免感慨，那时候这连串的记忆，对如今的我有多大影响——至少我现在回忆起来总是觉得许多地方感觉非常暖和。不过我今天重点不是记游戏的事情（以后有机会，可以写下），主要是那时候一些生活上的许多事情（可以说是被游戏影响着的），一直藏在心里，从来没有分享给别人。
现在想起来，那时候我也是够搞笑的，我父母管我也特别严格。也不能说是严格，而是颇为费解。我家里4年级的暑假买了电脑，不过后来玩的太过火，被拔网线电源了。喔，那个时候的家长好像管理所谓的网瘾少年，就是使用这种流行的方法。那时候上网还是拨号的，经过几年我才醒悟过来，我应该自己备一个适配的网线电源。不过还是由于玩的太过火被发现了，又被没收了。
后来周末能够玩的时候就非常少了，于是我开始去朋友家玩。我爸妈的工作是晚睡晚起的，那时是早上12点起，凌晨2，3点睡觉的模式（以前我觉得很自然，现在上了大学反而觉得当年父母的生活习惯竟然如此不可思议）。于是我早上6点便起床跑到500米远的朋友家去玩了。那时我们都迷恋同一个网游。那时候对游戏的深度讨论丝毫不亚于如今学计算机的一些讨论，可能我们天生就有这样的专注，只不过需要先找到迷人的事物。
不过，没过多久，我妈就发现了，她其实早上会有起床的习惯。于是，她早上7点便来到朋友家楼下，嘶吼着我的名字。我听到了又害怕又尴尬，我只好下楼，任凭我妈对我的拉扯和训斥，直到我躺到自己的床上才作罢。有趣的不是这件事，而是这件事一直持续了大概一年。每次周末，我早上都是如此度过的。像极了叛逆的孩子（大概就是叛逆的孩子吧），跟父母作对。但我的关注点不在这里，我的脑子里全是游戏，虽然不妨碍我上学期间的专注，但是一到周末，我的心都飞到朋友家。
说起来，天刚亮就偷跑出去，这种事情在我没有电脑前也做过无数次了。有跑到野地看日出过，也有专门观察黎明时刻冷清的街道如何变的热闹的。路边的早餐店，卖鸡蛋饼的女人是如何工作的。当然，做的最多的是去游戏厅。不可思议，那时候的游戏厅居然有6点就开的（虽然小学以后再也没有去过游戏厅了）。我进去就是玩《棒球小子》，等人多了，我去玩《拳皇97》或者《拳皇2000》。
上了初中，玩游戏就规律多了。平时住宿，回家只能周五和周六晚上玩。那时候一天就只能玩4小时了，现在如果要做一件事，4小时实在太少了，以前却可以玩的很开心。上高中之前，没有电脑的我是跟电视过的，我会把每个频道翻过去，找到喜欢看的节目。到了高中，有了手机，开始整体刷qq了。电视已经很少看了，电影也慢慢旧了，之前也修过很多次，最后是半可用状态，不过那时候我已经有养成追几部热血漫的习惯了，所以基本作为电视看了。 电视还真的是具有非常特殊的意义——电脑不是，电脑总是在身旁，大概反而不给人怀旧感。</description>
    </item>
    
    <item>
      <title>我的五月反思</title>
      <link>/blog/posts/2018%E5%B9%B45%E6%9C%88%E5%8F%8D%E6%80%9D/</link>
      <pubDate>Sun, 06 May 2018 22:48:58 +0000</pubDate>
      
      <guid>/blog/posts/2018%E5%B9%B45%E6%9C%88%E5%8F%8D%E6%80%9D/</guid>
      <description>懒惰的自己与混沌的事情 首先恭喜自己美赛拿了M奖。然后接下来的话都是对这一个多月的反思。
读书 之前提到的要看的几本书。 - 《C++性能优化指南》随便看了几章后就还回去了，暂时用不到，可能需要工作2，3年才能有较深刻的体会，不然现在看都是一些大道理罢了，虽然知道这么做非常多，但是因为没有这些编码经验导致印象非常模糊，无法自发地去利用这些知识。 - 《Effective Modern C++》这本书一直在看，已经看了半本左右吧。我读的是英文版，而且是乱序读的，对哪个 Item 感兴趣就读哪个。这本书基本是对 C++11 C++14 的新特性总结与避坑。这些新特性有一半我已经接触过了，所以有些 Item 看起来还好，只需要注意几个细节。而有些特性平时使用不到，理解不够深刻，读起来也是懵懂的。 - 《深入理解JVM》这本书是几乎全部快速扫过一遍了。可惜啊，现在很多记不清了，只有一些感性的认知记忆了。毕竟许多知识就是需要多遍的理解并且实践才能获得真正的深刻。 - 《Scala函数式编程》，这本难度还是超出了我的预期。它把太多的内容交给了读者自己去编写，而且我觉得它里面的部分内容组织的有一定问题，后面也全然不提 Scala 的那些语法，以至于得自己先去了解那些语法。目前为止我粗略读了半本，但是习题才写到第五章。 - 《算法新解》，惭愧。后来就几乎没有看了，它偏重于函数式，所以可以说跟本科要求的数据结构已经不怎么搭了。而且这本书大多数内容引用了一个博士论文——专门研究函数式数据结构的论文，可见这本书其实没有作者所说的非常基础。
除了以上几本计划内的书，其实还有好多本计划外的书，比如《七周七语言》，非常好的书，不过难度也是比较大的，我主要是把它当做扩展自己的视野的科普书来看的。之前的 Lua 那篇博客就是整理自该书，遗憾的是后面的那些内容太庞杂了，没有精力继续整理。还有个比较重要的是 《Programming in Scala, Third Edition : A comprehensive step-by-step guide》，这是 Scala 之父的作品。我直接读英文版，已经接近半本了。实话说，我觉得我还是没怎么掌握——我真的编码太少了。这本书真的挺厚的，堪比《C++ Primer》，Scala 本身复杂度也是不亚于 C++ 的。
其实对一些书的总结挺没有意思的，并不能真正看出自己学到多少。而且想看的书一直在增多和变化着，感觉变得越来越乏力。
复习 前几天终于开始复习高数了，不过非常不顺利，甚至没有找到学习高数的感觉。讲义内的一些题目非常灵活、综合，连选择题的解析也把各个选项当证明题来做。这时候，基础的知识和定义需要理解的清楚而深刻。不幸，我一直不擅长记忆，一连串的定义要精确的记忆理解压垮了我的脑袋。于是，在图书馆按捺不住，没隔多久就打道回府了。
我发现了我缺少了克服一些客观问题和主观问题的意志力，也缺少把计划铭记于心然后执行的习惯。我计划稍后在纸上写下学习计划表，精确到小时，并且随身携带着。有些坏习惯或好习惯必须得靠主观意志来去去除或者养成。
方向 就在刚才，我查了许多关于 PLT 的资料，几乎全是英文的，而且许多大量的前置知识。PLT 是指 Programming Language Thesis，这个国内真的很少。全是非常好的学校才有那么一点点人搞这个方向。基本是偏数学（较强的数理逻辑知识是基础）的方向了，这样看来，我现在几乎是*零基础*（大概学习了一些函数式编程是我在这方向的唯一的基础了），而国内顶尖高校高年级是有开相关的课程的。其实我也间歇性地搜集过 PLT 相关的资料，涉及面太庞大了，PLT 其实本身非常庞大，纳闷的是为什么国内搞这个方向的人这么少。知乎可能是我目前唯一能搜到许多理想的 PLT 相关资料的地方了。入门可能是最麻烦的了，看那些搞 PLT 人在知乎的答案，总是一头雾水。
我想我很可能就是要往这方向发展了（抛开目前的水平不谈，我个人意向就是想学习跟编程语言本身强相关的方向），所以才打算考研，搞这个方向的学校也真是屈指可数。
以我目前的情况嘛，大概主要时间放在考研复习上了，平时偶尔看看基础的 PLT 知识，主要是深入学习 Haskell 吧， Haskell 深入了，大概许多 PLT 的方向也能慢慢摸索出来了。</description>
    </item>
    
    <item>
      <title>七周七语言2-Lua</title>
      <link>/blog/posts/%E4%B8%83%E5%91%A8%E4%B8%83%E8%AF%AD%E8%A8%802-lua/</link>
      <pubDate>Fri, 20 Apr 2018 21:37:57 +0000</pubDate>
      
      <guid>/blog/posts/%E4%B8%83%E5%91%A8%E4%B8%83%E8%AF%AD%E8%A8%802-lua/</guid>
      <description>Lua Lua一览 Lua 是一门基于 table 的编程语言，它的核心抽象层简单而强大，你可以用它实现过程式、面向对象、事件驱动等。 Lua 的 table 很适合基于原型的面向对象编程。这种编程风格中，类和实例不是割裂的概念。你先创建一个实例，这个实例看起来像你需要的对象。然后你再把这个实例复制多份，对每一份做一些定制化。
初窥 Lua 的语法友好，并且易于接近，无须担心分号或者空格写哪里。空格对 Lua 来说不太重要，两个语句之间甚至不需要换行。Lua 使用 &amp;ndash; 来注释。
以下示例主要在REPL中运行。
&amp;gt; print &amp;quot;hello world&amp;quot; hello world &amp;gt; print &amp;quot;hello world&amp;quot; &amp;gt; print &amp;quot;hello world&amp;quot; print &amp;quot;hello world&amp;quot;  Lua 基础 Lua 是动态类型的，也就是说代码中的变量不需要声明类型，在运行时才会决定其具体类型。Lua 的基础类型有： - 数字 - 布尔值 - 字符串
&amp;gt; 3.14 3.14 &amp;gt; true true &amp;gt; &amp;quot;hello world&amp;quot; hello world &amp;gt;  Lua 没有整数，就跟 JS 一样。字符串也可以使用单引号，也使用反斜杠转义特殊字符或不可见字符。
字符串可以用 .. 来拼接，用 # 来获取长度。</description>
    </item>
    
    <item>
      <title>Hadoop Install</title>
      <link>/blog/posts/hadoop-install/</link>
      <pubDate>Fri, 20 Apr 2018 16:13:59 +0000</pubDate>
      
      <guid>/blog/posts/hadoop-install/</guid>
      <description>Hadoop Install 我采用的是 linux 下的 hadoop 安装，本安装文档说明前提是已经全局安装了open-jdk1.8(也可以使用 hotspot jdk)。本文档主要参考官方文档。部分英文由自己补充和改写，主要内容翻译为中文。
Required software for Linux include:
Java™ must be installed. Recommended Java versions are described at HadoopJavaVersions.
ssh must be installed and sshd must be running to use the Hadoop scripts that manage remote Hadoop daemons.
Installing Software 以下是必需的软件。
$ sudo apt-get install ssh $ sudo apt-get install rsync  Download To get a Hadoop distribution, download a recent stable release from one of the Apache Download Mirrors.</description>
    </item>
    
    <item>
      <title>2018学习和复习</title>
      <link>/blog/posts/2018%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Tue, 20 Mar 2018 19:21:06 +0000</pubDate>
      
      <guid>/blog/posts/2018%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%A4%8D%E4%B9%A0/</guid>
      <description>2018学习和复习 大学做过无数次计划，似乎少有完全达成，这样看来，其实是自己的问题。所以特此再做一次计划，计划不会特别具体，但要让自己严格执行。
学习 把学习和复习分开来计划其实是很明智的。复习计划是与考研强相关的，学习计划则是与专业强相关，与考研弱相关的。当然介于考研其实是场持久战，而且如果要考408的话，复习时间其实是很紧的，所以复习期间看考研不相关的东西其实是不太明智的，除非能提早开始准备。 当然，我这个人就这样，不喜欢总是做一些课内的或者合时宜的事情，偶尔会在课外捣鼓一些其他东西。这次准备看一些感兴趣的又能对考研的复习有一定作用的书籍。 首先是最近已经在看了的，《Scala函数式编程》。因为课内可能需要捣鼓大数据，分布式什么的，这本书可以学习到一些Scala编程，其实有一定帮助。但对考研帮助不大，可能里面涉及到的少部分函数式数据结构，是对复习数据结构有帮助，但是其实应该不明显的。这本书习题蛮多的，后面还特别吃力。所以最近可能会缓一缓，基本上一个月看一章足矣。记得寒假看了点《JS函数式编程》和《Haskell趣学指南》，其实已经学到了不少函数式知识了。Scala这本也基本没超出之前所看的，唯一区别的是这本难度更大，而且有大量习题。 第二本是《算法新解》，这本也开始看了，不过没有前者看深刻。这本除了图数据结构以外，基本囊括了数据结构这门课的知识点并且还有许多高级数据结构，除此之外还增加了近一半函数式数据结构和算法。这本应该不会全看完，视情况而定。前期数据结构复习以此为准，毕竟要对自己更高要求嘛。 未来几个月打算看的书有《深入理解JVM》，《Effective Modern C++》，《C++性能优化指南》。这几本书只打算在这个学期和暑假的时候看下，3本通读半本内容后，就作为参考了。 接下来说说我为什么选这3本。 《深入理解JVM》早就想看了，因为以前厌恶Java的原因导致我也不想了解JVM。许多Java实习生，其实应该看这本书，因为对他们面试和工作都有用处。不过对我而已，这本书其实在讲虚拟机的体系结构罢了，它其实就只是在计算机系统结构上又抽象出了一层体系结构。这样说来，了解过JVM的体系结构以后，其实对计算机体系结构甚至操作系统也有比较大的帮助。考虑到考研可能要考组成原理，而组成原理与系统结构其实知识点很相近，所以说这本书对组成原理复习是有一定帮助的。 《Effective Modern C++》，这本是在大一学C++的时候就想要读了。然而，那时候功底不够，后来大二的时候接触C++比较少了，而且有对C++一些历史原因和特性的无奈与恐惧，还有英文功底不好等原因，没有看。最近开始拿C++刷题了，又扫过几眼C++的书，觉得对STL掌握更好了，最后是因为Rust，导致我挺想看的。 《C++性能优化指南》，这本我其实一点也不了解，单纯看目录，感觉对自己的底层编程有帮助，姑且作为参考吧。
复习 身边人都陆陆续续开始复习了，而我课程其实不少，始终只是在记单词和刷点题。当数学复习开始的时候，大概就是正式进入复习状态吧。网上查说数学复习开始时间是3-6月，而专业课复习开始是6-7月。所以我计划5月一定要开始数学复习，而专业目前只看数据结构并且刷题。专业课7月正式开始。其实这样真的蛮紧张的，所以英语复习是每天都不能松懈的，并且争取这次过6级。 关于复习资料，目前还没收集全，每周会查阅一些信息来补充复习计划。
关于PAT刷题计划： - 3月，前一百题，刷完20分的题。 - 4月，前一百题，刷完25分的题。 - 5月，前一百题，刷完30分的题。 - 暑假，刷完最后的题。
整体上复习大纲就是这样，坚持下来，就会收获。</description>
    </item>
    
    <item>
      <title>2018新年与考研</title>
      <link>/blog/posts/2018%E6%96%B0%E5%B9%B4%E4%B8%8E%E8%80%83%E7%A0%94/</link>
      <pubDate>Wed, 07 Mar 2018 13:57:37 +0000</pubDate>
      
      <guid>/blog/posts/2018%E6%96%B0%E5%B9%B4%E4%B8%8E%E8%80%83%E7%A0%94/</guid>
      <description>2018新年与考研 新年 新的2018年到来了，还没用文章对自己过去一年做一个总结。寒假的时候参加美赛，奈何自己太菜，估计只能获得一个参赛奖吧，好像也没什么好说的。
寒假的后半段基本是自学一些感兴趣的东西，比如Haskell、Rust、Scala，主要是学习函数式编程吧，不过其实也就才刚入门的水平而已。除此之外，还在查阅一些考研相关的资料与信息，因为一直以来都有考研的打算，毕竟GPA不理想，没有机会保研嘛。
现状与打算 到了大三下，大部分同学的课表就比较空了，但我可能还是蛮多的，跟大一上的时候差不多吧，不过幸好很多是选修课，不过这些选修课也都挺严格的。而创新实践课老师这个学期给了很多方向，让我们自己选择感兴趣的去学习，只要能真得学到东西就好了。我觉得这样挺不错的，之前的数据可视化我就不太感冒，自己的几何知识真的不太好。虽然现在也是数据可视化相关的，但是细分下来，可以有很多具体的不同方向的知识。比如做数据处理相关的，大数据方向。具体点就是学习分布式处理框架比如hadoop、spark、storm之类。如果硬要说兴趣的话，对这些还是有一点点兴趣的。至于可视化还有一些其他的工作，就交给其他组员做吧。当然我不满足于只是用用这些框架，虽然会应用是很重要，但是我打算学一些分布式系统的知识，这样学习也更深刻。比如CMU和MIT的分布式课，都有公开的，不过好像都是研究生级的课，而且资料不太全，可能很麻烦，这个具体看情况吧。
其实要学的东西还真不少，再加上考研的复习，可能每天都很忙碌。我其实不清楚自己的计划可不可行，但是每天不接触点新知识总是不自在，而复习老知识相对比较枯燥，即使我没有掌握好。
除此之外，在mooc大学平台上，还参加1，2门网络课，跟考研知识比较紧密，但不是为考研而开设的课程，其实也就是CSAPP（我其实基本看完了，课后练习大部分也做了，当然家庭作业都没有做，不过对上个学期操作系统的考试并没有什么帮助。。。）吧，相当于把编译加载，组成原理，操作系统结合的课程，当然不可能讲到那么细，只是学习它们很紧密的地方。这样也能大概巩固操作系统和计组的知识吧。如果我要考浙大的话，就是考408了。需要计网，操作系统，组成原理，数据结构四门核心课的复习。这样能确实有不少的复习作用，而且是从不同角度学习的，因此也有许多新知识，不会枯燥。
数据结构我打算刷PAT，下次考试好像是8月左右，因此时间还蛮充裕的，配套练习有139题，争取全刷了。还有自己准备的一本《算法新解》，比考研难度要高，但是可以作为复习。还有一本《Scala函数式编程》，其实这本跟数据结构和算法关系不大，但是里面少部分还是对数据结构和算法有一定要求和锻炼的。
除了计算机知识，还有英语和数学是这个学期就要开始了，先不考虑政治。数学我打算可能要晚一点再开始，英语现在每天记单词吧，偶尔可能刷刷其他知识点。姑且先这样吧，可能先适应1，2周并且打听打听其他人的学习情况。所以这个月重点在数据结构和英语了吧。
当然还有课内要规划下，重点在分布式系统这块吧。网络编程这门课感觉有点水，打算退了选择云计算，这样也跟创新实践比较紧密些，可以减少负担。 还有一门日语课也是重点，虽然跟考研完全无关，也没有帮助。但是既然自己已经选择了，那就好好学习。这门课一周4节，我估计学完了也就N5的水平了吧，听说N3,N4,N5都没什么用。所以路还长吧，N2好像至少要学2年。如果非要说点希望的话，希望自己本科可以把日语学到N3吧，当然英语更不必说了。
姑且先写到这里吧。</description>
    </item>
    
    <item>
      <title>JS函数式编程笔记2</title>
      <link>/blog/posts/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B02/</link>
      <pubDate>Wed, 07 Feb 2018 14:27:31 +0000</pubDate>
      
      <guid>/blog/posts/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B02/</guid>
      <description>JS函数式编程 笔记里面常常依赖一些库和之前的代码，而且可能存在理论上的代码和未实现的函数，阅读时，需要仔细。
下面部分经常的东西后面经常用到，我先导入。
const curry = require(&#39;lodash/curry&#39;) const _ = require(&#39;lodash&#39;) const fp = require(&#39;lodash/fp&#39;) const moment = require(&#39;moment&#39;) let compose = function(f, g){ return function(x){ return f(g(x)) } } let toUpperCase = function(str){ return str.toUpperCase() } let toLowerCase = function(str){ return str.toLowerCase() }  Hindley-Milner 类型签名 初识类型 刚接触函数式编程的人很容易深陷类型签名（type signatures）的泥淖。类型（type）是让所有不同背景的人都能高效沟通的元语言。很大程度上，类型签名是以 “Hindley-Milner” 系统写就的。
类型签名在写纯函数时所起的作用非常大，大到英语都不能望其项背。这些签名轻轻诉说着函数最不可告人的秘密。短短一行，就能暴露函数的行为和目的。类型签名还衍生出了 “自由定理（free theorems）” 的概念。因为类型是可以推断的，所以明确的类型签名并不是必要的；不过你完全可以写精确度很高的类型签名，也可以让它们保持通用、抽象。类型签名不但可以用于编译时检测（compile timechecks），还是最好的文档。所以类型签名在函数式编程中扮演着非常重要的角色——重要程度远远超出你的想象。
// capitalize :: String -&amp;gt; String let capitalize = function(s){ return toUpperCase(head(s)) + toLowerCase(tail(s)) } console.</description>
    </item>
    
    <item>
      <title>IEEE802.11概述</title>
      <link>/blog/posts/ieee802.11%E6%97%A0%E7%BA%BFlans%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Tue, 26 Dec 2017 22:03:46 +0000</pubDate>
      
      <guid>/blog/posts/ieee802.11%E6%97%A0%E7%BA%BFlans%E6%A6%82%E8%BF%B0/</guid>
      <description>IEEE 802.11无线 LANs 概述 无线链路和网络特征 802.11协议簇是国际电工电子工程学会（IEEE）为无线局域网络制定的标准。虽然WI-FI使用了802.11的媒体访问数据链路层（DLL）和物理层（PHY），但是两者并不完全一致。
这里主要概述了 802.11无线LAN的特征。不过首先应该关注的是无线网络与有线网络的区别。
当我们寻找有线和无线网络的重要区别时，应该重点关注链路层，我们确实可以发现有线链路和无线链路有许多重要区别：
 递减的信号强度。信号强度受到发送方和接收方距离的增加而递减。 来自其他源的干扰。在同一个频段发送信号的电波源会互相干扰。 多径传播（multipath propagation）。当电磁波受到反射，会在发送方和接收方之间走过多条不同长度的路径，此时出现多径传播，这使得接受的信号变得模糊。  IEEE 802.11 标准 常见的关于LAN的802.11标准包括 802.11b、802.11a、802.11g等。 它们使用相同的媒体访问协议CSMA/CA，并且使用相同的链路层帧格式。
802.11 体系结构 802.11 体系结构的基本构建模块是基本服务集（Basic Service Set BSS），一个BBS包含若干个无线站点和一个被称为接入点（AP）的中央基站。与以太网设备类似，每个802.11无线站点都具有6字节的MAC地址。每个AP的无线接口也具有一个MAC地址。这些MAC地址也由IEEE管理，理论上全球唯一。
信道与关联 在802.11中，每个无线站点在发送或者接受网络层数据前，必须与一个AP相关联。而安装一个AP时，需要为其分配单字或者双字的服务集标识（SSID）。除了SSID，还需要分配一个信道号。
信道：
802.11定义了11个部分重叠的信道，当且仅当2个信道由4个或更多的信道隔开时，它们才不重叠。比如 1、6、11是唯一的3个非重叠信道集合。这样就可以在同一个物理网络安装3个AP。
关联：
为了获得互联网接入，你的无线站点需要加入其中一个子网并需要与其中一个AP相关联（associate）。关联意味着该无线站点在自身与该AP之间创建了一个虚拟线路。
然而，首先得回答：你的无线站点如何与某个特定的AP相关联？或者你的无线站点如何知道当前位置哪个AP可以使用？
802.11标准要求每个AP周期性地发送信标帧（beacon frame），每个信标帧包括该AP的SSID和MAC地址。 你的无线站点为了得知正在发送信标帧的AP，扫描11个信道，找到可能来着可能位于该区域的AP所发出的信标帧。
不过，802.11标准没有指定选择哪个可用的AP进行关联的算法，这个由802.11固件和无线主机的软件设计者来设计。 比如，主机选择接收到的具有最高信号强度的信标帧，但可能过载。
这里扫描分两种：
 被动扫描（passive scanning），自AP发送信标帧，无线站点*扫描信道*和*监听信标帧*，然后向选择的AP发送*关联请求帧*，最后AP响应关联响应帧 主动扫描（active scanning），无线站点广播*探测请求帧*，AP发送*探测响应*，然后无线站点选择AP发送*关联请求帧*，最后AP响应关联响应帧  鉴别与接入 为了与特定的AP创建关联，某无线站点可能需要向该AP鉴别它自身。
802.11 提供了几种不同的鉴别和接入方法
 基于站点的MAC地址允许其接入网络 基于用户名和口令  上述两种情况下，可能使用的RADIUS（基于UDP）和DIAMETER（最初作为RADIUS的改良）这样的协议。</description>
    </item>
    
    <item>
      <title>JS函数式编程笔记1</title>
      <link>/blog/posts/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B01/</link>
      <pubDate>Mon, 11 Dec 2017 21:47:31 +0000</pubDate>
      
      <guid>/blog/posts/js%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B01/</guid>
      <description>JS函数式编程 我们在做什么  “we both know what happens when you assume”，源自一句名言“When you assume you make an ASS of U and ME”，意思是“让两人都难堪”）。但我猜想你在使用可变状态（mutable state）、无限制副作用（unrestricted side effects）和无原则设计（unprincipled design）的过程中已经遇到过一些麻烦。
 现在已经有一些通用的编程原则了，各种缩写词带领我们在编程的黑暗隧道里前行：DRY（不要重复自己，don&amp;rsquo;t repeat yourself），高内聚低耦合（loosecoupling high cohesion），YAGNI （你不会用到它的，ya ain&amp;rsquo;t gonna need it），最小意外原则（Principle of least surprise），单一责任（single responsibility）等等。这些原则同样适用于函数式编程(FP)。
先看基本的例子
let add = function (x, y) { return x + y }; let multiply = function (x, y) { return x * y }; let a = 4; let b = 2; let c = 0; let result = add(multiply(b, add(a, c)), multiply(a, b)); //=&amp;gt;16  你会发现我们不过是在运用古人早已获得的知识</description>
    </item>
    
    <item>
      <title>DNS知识点</title>
      <link>/blog/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C/</link>
      <pubDate>Sat, 11 Nov 2017 09:40:04 +0000</pubDate>
      
      <guid>/blog/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C/</guid>
      <description>DNS DNS 是域名系统（Domain Name System）的缩写，它是一种用于 TCP/IP 应用程序的分布式数据库，它提供主机名字和 I P 地址之间的转换及有关电子邮件的选路信息。所谓“分布式”是指在 Internet 上的单个站点不能拥有所有的信息。每个站点（如大学中的系、校园、公司或公司中的部门）保留它自己的信息数据库，并运行一个服务器程序供 Internet上的其他系统（客户程序）查询。
DNS 命名方式中，采用了分散和分层的机制来实现域名空间的委派授权，以及域名与地址相转换的授权。通过使用 DNS 的命名方式来为遍布全球的网络设备分配域名，而这则是由分散在世界各地的服务器实现的。
DNS 工作流程 域名服务分为客户端和服务器端，客户端提出请求，询问一个 Domain Name 的 IP 地址，服务器端必须回答客户端的请求。本地 DNS 首先查询自己的数据库，如果自己的数据库中没有对应的 IP 地址，则向本地 DNS 上所设的上一级 DNS 询问，得到结果之后，将收到的结果保存在高速缓冲区，并回答给客户端。标识字段由客户程序设置并由服务器返回结果。客户程序通过它来确定响应与查询是否匹配。16 bit 的标志字段被划分为若干子字段
DNS 协议 标志中每一位的含义如下：
 QR：是 1 bit 字段，0 表示查询报文，1 表示响应报文。 Opcode：报文类型，是一个 4 bit 字段，通常值为 0（标准查询），其他值为 1（反向查询）和 2（服务器状态请求）。 AA：是 1 bit 字段，表示“授权回答（authoritative answer）”，如果此位为 1，表示服务器对问题部分的回答是权威性的。 TC：是 1 bit 字段，表示“可截断的（truncated）”。使用 UDP 时，它表示当应答的总长度超过 512 字节时，只返回前 512 个字节。 RD：是 1 bit 字段，表示“期望递归（recursion desired）”。该比特能在一个查询中设置，并在响应中返回。这个标志告诉名字服务器必须处理这个查询，也称为一个递归查询。如果该位为 0，且被请求的名字服务器没有一个授权回答，它就返回一个能解答该查询的其他名字服务器列表，这称为迭代查询。 RA：是 1 bit 字段，表示“可用递归”。如果名字服务器支持递归查询，则在响应中将该比特设置为 1。 Zero：随后的 3 bit 字段必须为 0。 Rcode：是一个 4 bit 的返回码字段。通常的值为 0（没有差错）和 3（名字差错）。名字差错只有从一个授权 DNS 服务器上返回，它表示在查询中制定的域名不存在。随后的 4 个 16 bit 字段说明最后 4 个变长字段中包含的条目数。对于查询报文，问题（question）数通常是 1，而其他 3 项则均为 0。类似地，对于应答报文，回答数至少是 1，剩下的两项可以是 0 或非 0。  DNS 抓包 这里DNS报文首部前16bit格式如下：</description>
    </item>
    
    <item>
      <title>2017-11-5小结</title>
      <link>/blog/posts/2017-11-5%E5%B0%8F%E7%BB%93/</link>
      <pubDate>Sun, 05 Nov 2017 20:17:06 +0000</pubDate>
      
      <guid>/blog/posts/2017-11-5%E5%B0%8F%E7%BB%93/</guid>
      <description>10月 10月就这样过去了。当我觉得这样的10月是多么繁忙的时候，11月时候的我告诉自己，其实大部分时间是自己折腾自己罢了，而且毫无意义。
10月的作业债11月总是要还的。现在回想起来，好像是各个方面都在学习，但如蜗牛一般，于是乎，忘记自己走到了哪里。唯一欣喜的是，我开始接受其他书籍的洗礼了。之前从同学那儿借来了东野圭吾的《解忧杂货店》，每天熄灯后一小时都在咀嚼此书。跟计算机书籍比起来，这样的书确实容易读很多，不费太多的时间就能通读一遍，而且相当的有收获。当然，如果一本书没有从思想层面影响你，或者没有改变你的某个观念，或者没有改变你的一个习惯，或者没有引起你一点儿的思考，这样的书大概是不值得去读的。如某些读者所述，这本书确实在某方面治愈了我，让我感觉到人间一些温情，人与人之间不可思议的联系，很多无意义之事其实蕴含意义，不论好坏。其实我极力追求做一个足够纯粹的人，而我理解的纯粹是指一个的品质而不是性格。这本书里的人有些已经达到了我想追求的纯粹了。而我对纯粹的一些理解就是看淡大部分事情，对人的追求做到坦实真诚，对事的追求做到实事求是，对物的追求做到己所不欲。当然这里的追求比较广义。可能思想更接近于道家，当然我完全不懂这些思想家的大道理。讽刺的是，我一直没有做好，不然可能也不会写这些了。
刚刚提到走着走着忘记走到了哪里。其实就是没有把握本心的缘故吧。原因无外乎就是意志力的不坚定，间接性情绪调节不良。10月份做了什么自己满意的事情？有把该完成的都及时正确地完成吗？除了课内，课外又扩展了多少？写到这里，能回答上的也就是10月份开始的跑步吧，频率还是挺高的，1周能跑4，5次。作业能提早完成的后来质量都出了问题……没有提早完成的基本拖到deadline。满意的事情，还真没有，我这个人不容易对事情感到满足，因为很容易就松懈下来，但实际上大部分时候我松懈的原因是因为失去了耐性或者热情，在这点上，还不如中学时代的自己，中学的我虽然在各方面的都很平庸（虽然现在依然），但做什么事情都饱含热情，是真的喜欢生活，喜欢与人交流。
11月 11月的第一周，基本宣告了学期过半。有什么收获自己心里清楚，没有完成什么自己心里清楚，还想做什么自己心里也清楚。人啊，总是会把生活中大部分事情当作理所当然，所以才不容易改变。我极力改变这样的思维，如何看待周围是一件非常严肃，非常需要思考，却被人忽略的事情啊。许多时候不能总保持着“我现在的这样状态真的很好啊”的想法，于是乎还想证明给其他人看。可能还有一种思考角度，我尝试往一个可能更好的习惯学习，如果反而没有帮助，再退回来。前者是以不变应万变，后者是以变应万变。最近开始尝试读一些文学作品，也是从此角度出发。一直读专业相关的作品或资料，当然对学习有很大帮助，但是人很难再脱离自己给自己建造的围墙了，它们既是梯子也是围墙啊。再谈到待人之事，摈弃过去看人优缺点的角度，而尝试以对方的角度看待对方自己，才能做到了解他人吧。
然后是想反思一下一直以来的一些学习缺陷。看比较费理解的书，还是容易倾向于不去深思，原因嘛，就是怕麻烦，觉得这是一场时间黑洞的无意义之旅，然后是有点急于求成，过分看轻一些基本之理。不过还是要承认下自己的记忆力不行，对经历的事情还算有正常的记忆力，但对文字和视频的记忆力特别差，目前感觉原因尚不明朗。
昨天把从同学那里借到了《独唱团》读了半本，今天才查了一下，原来是只出过一期，这个期刊本身还颇有一些故事。当然本身的内容也是不错，作者大多是80后70后吧？聚焦于上个世纪的中国，讲述各种经历，每篇都能透入一些观点，或批判或赞扬。
而我已经好久没有看过这样的散文、诗句、问答、半小说半叙事的文章了。看来我还是不排斥文学作品的，高中每周也会去买杂志跟期刊，看看感兴趣的内容，喜欢看里面待人处事的观点。我敢说我现在的思想跟性格被高中时代接触的内容严重影响了，即使现在我已经几乎想不起那些内容。只记得，他们在谈论生活，他们在谈论文化，透露着思想…… 里面的图片也总是能触动许多，有时候能盯着图片一分钟，思考着什么我早已经忘记了，大概在思考着他们所思考的事情。我想这本书，我应该也会尝试读完吧，感觉把过去的习惯捡起来，就好像在跟老朋友拥抱一般，非常的踏实。
发现写到这里，已经过去整整一小时了。大概我的脑子里又本能的计算着花一小时做这些事情的利弊了。看过的许多作品，我发现我都不能很好地把他们表达出来，或者借用一下，我想有机会写写探讨某些作品本身的博客，目前来说可能还不合适，阅历可能还不够。
已经九点半了，面对着书架上近百本的书，其实心里滋味很难描述。</description>
    </item>
    
    <item>
      <title>Install MySQL5.7</title>
      <link>/blog/posts/install-mysql5-7/</link>
      <pubDate>Thu, 26 Oct 2017 13:30:18 +0000</pubDate>
      
      <guid>/blog/posts/install-mysql5-7/</guid>
      <description>大二数据库原理的作业，发现还存在电脑里，于是稍微整理下放到博客里。
windows下mysql安装 我下载的是zip压缩包，假设解压到D:\software目录下，官网下载的只有服务端和简单的shell，可以去搜索Navicat客户端，支持多种数据库管理系统，下载MySQL客户端，也支持MariaDB使用。
注意：Navicat是收费的，免费使用14天。你还可以使用其他客户端，比如phpAdminMySQL。
mysql的简单配置 mysql的目录结构如下
环境变量需要配置bin目录，mysql的程序都在bin目录下，所以环境变量是在PATH变量上新增D:\software\mysql\bin。
各个版本目录可能不同，data目录存放系统数据，一开始应该没有，需要自己新建。
另一个重要的是my.ini文件(或my-default.ini)，需要进行一些简单的配置才能使用。
[mysql] # 设置mysql客户端默认字符集 default-character-set = utf8 [mysqld] #skip_grant_tables 这个先不要，这是忽略权限。 #设置3306端口 port = 3306 # 设置mysql的安装目录 basedir = &amp;quot;D:/software/mysql-5.7.16-winx64&amp;quot; # 设置mysql数据库的数据的存放目录 datadir = &amp;quot;D:/software/mysql-5.7.16-winx64/data&amp;quot; # 允许最大连接数 max_connections = 200 # 服务端使用的字符集默认为8比特编码的latin1字符集，我们改为通用的utf8 character-set-server = utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine = INNODB  常用的2个程序是mysql和mysqld，需要给服务端设置一些配置，如上，语法跟作用一目了然。
windows下运行mysql需要使用cmd管理员权限，使用net start mysql 启动mysql服务，net stop mysql 关闭服务。
一开始需要使用root帐号登录，不需要密码，在命令行下使用mysql -u root -p登录，进入shell后可以使用help命令查看简单的用法。
具体其他使用方法请查看文档手册或者搜索引擎。
Navicat 客户端简单使用 按照安装包的引导安装即可。
注意使用期限是14天。
Navicat界面比较简洁，也只提供基本的功能，如需要使用强大的功能可能需要购买或使用其他客户端。
Navicat窗口帮助下可以打开本地中文文档，可以查看各种数据库的使用。
在文件下建立数据库连接写好帐号密码即可连接（不要忘记先在cmd管理员权限下启动mysql服务）。
然后可以简单的开始操作DBMS了。</description>
    </item>
    
    <item>
      <title>VAET阅读稿</title>
      <link>/blog/posts/vaet%E9%98%85%E8%AF%BB%E7%A8%BF/</link>
      <pubDate>Wed, 11 Oct 2017 18:53:34 +0000</pubDate>
      
      <guid>/blog/posts/vaet%E9%98%85%E8%AF%BB%E7%A8%BF/</guid>
      <description>VAET: A Visual Analytics Approach for E-transactions Time-Series 电子交易时间序列的一种可视化分析方法  Cong Xie, Wei Chen, Member, IEEE, Xinxin Huang, Yueqi Hu, Scott Barlowe, and Jing Yang
 创新实践的论文阅读作业，翻译了主要内容，加上部分自己的理解并修改部分内容，保留了部分原文，有时候阅读原文更好理解。全文按照论文组织的方式编写，主要是为了理清楚论文的主要思想，并可以简单地给其他人做宏观上的解释，达到基本的教学目的。此文将作为ppt的前稿。
INTRODUCTION 介绍 The E-transaction time-series contains transactions among multiple users in a time range. Each record contains a time stamp, the IDs of the seller and buyer, and the associated attributes of the commodities. Each record is an atomic element representing an online transaction among a seller and a buyer.</description>
    </item>
    
    <item>
      <title>计算机系统结构</title>
      <link>/blog/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</link>
      <pubDate>Thu, 28 Sep 2017 19:48:52 +0000</pubDate>
      
      <guid>/blog/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</guid>
      <description>系统结构的部分课后作业，因为需要写成电子版，故稍微整理下也放入到博客中，方便你我他。答案是自己组织的，不保证一定正确。 书是张晨曦的《计算机系统结构（第2版）》
第一章 1 翻译技术是先把 L+1 级程序全部变换成 L 级程序后，再去执行新产生的 L 级程序，在执行过程中 L+1 级程序不再被访问。
解释技术是每当一条 L+1 级指令被译码后，就直接去执行一串等效的 L 级指令，然后再去取下一条 L+1 级指令，以此重复进行。
计算机系统结构是程序员所看到的计算机属性，即概念性结构与功能特性。
Amdahl定律：加快某部件执行速度所能获得的系统性能加速比，受限于该部件的执行时间占系统中总执行时间的百分比。
程序的局部性原理是指程序执行时所访问的存储器地址不是随机的，而是相对簇聚。局部性原理又表现为：时间局部性和空间局部性。 时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。 空间局部性是指一旦程序访问了某个存储单元，则不久之后。其附近的存储单元也将被访问。
CPI(Cycles Per Instruction，每天指令的周期数) CPI = 执行程序所需要的时钟时间 / 执行指令个数。
模拟是指用软件的方法在一台现有的计算机（宿主机host）上实现另一台计算机（虚拟机VM）的指令集。
仿真是指用一台计算机（宿主机host）上的微程序去解释实现另一台计算机（目标机）的指令集。
3 Flynn分类法是按照指令流和数据流的多倍性进行分类的。
Flynn分类法把计算机系统结构分为以下4类：
 单指令流单数据流（SISD） 单指令流多数据流（SIMD） 多指令流单数据流（MISD） 多指令流多数据流（MIMD）  4 计算机系统设计经常使用的4个定量原理
 以经常性事件为重点，按照对经常性情况采用优化方法的原则，能得到更多整体上的改进。 Amdahl定律，加快某部件执行速度所能获得的系统性能加速比，受限于该部件的执行时间占系统中总执行时间的百分比。 CPU性能公式，CPU时间 = 时钟周期时间 x CPI x IC，只要改进任何一个参数都能提高CPU性能 程序的局部性原理，程序执行时所访问的存储器地址不是随机的，而是相对簇聚。  6 执行时间 = 0.000575(s)
CPI =(45000 + 750000 * 2 + 8000 * 4+ 1500 * 2) / （45000 + 75000 + 8000 + 1500）~= 1.</description>
    </item>
    
    <item>
      <title>人工智能发展报告</title>
      <link>/blog/posts/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8F%91%E5%B1%95%E6%8A%A5%E5%91%8A/</link>
      <pubDate>Sun, 24 Sep 2017 19:29:28 +0000</pubDate>
      
      <guid>/blog/posts/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8F%91%E5%B1%95%E6%8A%A5%E5%91%8A/</guid>
      <description>人工智能的发展 数据挖掘课程的作业报告，放在这里分享一下，都是一些蠢话。 符号主义（逻辑主义） 推理期 二十世纪五十年代到七十年代初，人工智能的研究处于“推理期”，那时候人们普遍认为机器获得智能的方法是赋予机器逻辑推理的能力。该阶段比较有代表的工作比如在1955年12月，赫伯特·西蒙（Herbert Simon）和艾伦·纽厄尔（Allen Newell）开发出逻辑理论家，这是世界上第一个人工智能程序，有能力证明罗素和怀特海《数学原理》第二章52个定理中的38个定理， 甚至在后来证明了全部52个定理。这两位也因此在1975年获得了图灵奖。
知识期 随着后来的研究进展，人们意识到仅仅具有逻辑推理能力是远远无法实现人工智能的。从二十世纪七十年代中期开始，人工智能的研究进入知识期。专家系统被大量开发出来，E.A. Feigenbaum 作为“知识工程”之父在1994年获得图灵奖。不过后来人们又意识到专家系统的“知识工程瓶颈”，把人类总结的知识教授给计算机是相当困难的。
机器学习 八十年代左右，“从样例中学习”的一大主流还是符号主义的思想，其代表如决策树（Decision tree）和基于逻辑的学习。决策树以信息论为基础，而基于逻辑的学习是归纳逻辑程序设计，可看作是机器学习与逻辑程序设计的交叉。
神经网络（联结主义） 九十年代中期之前，“从样例中学习”的另一个主流是基于神经网络的联结主义。1986年，D.E. Rumelhart 等人重新发明了BP算法，产生了深远影响，如今的深度学习最基本的概念便是BP算法。不过联结主义产生的是“黑箱”模型，从知识获取角度看有明显的弱点。然而，由于BP算法，深度学习算法在实际中非常有用，在2006年开始第三次神经网络高潮以深度学习之名重新爆发而来，在2012年之后成为人工智能的主流算法。当然，在九十年代统计学习兴起时，而又因为当时的局限性，曾经落入低潮。
统计学习 九十年代中期，“统计学习”迅速兴起并成为主流，如今依然是主流的机器学习算法，典型代表是SVM。早在九十年代之前，统计学习的许多基础理论已经出现，但因为联结主义的神经网络在九十年代具有局限性而没落后，统计学习被人瞄准目光而迅速流行起来。
谈谈自己的理解 前面的一些概括是我认为比较重要的历史的整理。如今看来，人工智能的历史虽然不漫长，却可以说的上丰富与多变。现如今，从学术、商业、工业角度来审视的人工智能，占据主流的是传统机器学习跟深度学习，然后才是强化学习跟规则学习（个人看法）。当然，如今的机器学习算法或多或少都用上了概率统计的知识。
深度学习如今越来越火热，在我自己开始留意机器学习的内容开始，深度学习相关的文章跟新闻就狂轰滥炸地映入我的眼里，以至于我没法不正视它。后来我也简单的接触深度学习，才发现它确实不可思议。在训练深度学习时，它就是在特征空间里不断逼近然后拟合到数据特征的“万能函数”，怪不得说它是万能近似图灵机。把它应用到许多领域感觉也就不奇怪了，当然它不一定比传统的机器学习和其他人工智能算法要更有效。
不过可能是因为深度学习的万用性导致它的黑箱性，大部分人在使用它来解决问题的时候，没有获得很好的解释，无论是从深度学习结构模型的理论角度还是问题本身特性的角度。只是在设计网络架构时，粗略地分析问题的特性，然后改良别人成功的架构跟“合理”的解释来解决问题。在问题较满意的解决后，没有合理的可解释性或者干脆从他人理解的来解释。
当然，从实用性跟工作角度来说，我觉得这样没错。深度学习跟你的剪刀和锤子一样，只是解决问题跟生产的工具，并不需要在意内部机理。这样的比喻来解释可能非常不妥当，不过我想表达的是，如今主流的人工智能方法：深度学习，虽然在构造时有比较好的理论基础，但在优化模型，优化架构，并且在解释优化可能性与优化思路上，缺乏理论。（对深度学习接触才几周，造成这样可能有偏差的认知，如有错误，欢迎指出）
相比于深度学习，传统偏向于统计的机器学习，可解释性就比较强了，而且在很多时候，从各种角度上与深度学习比较，丝毫不逊色。而且现实的问题非常复杂，蕴含大量不确定跟随机的事件，而概率论与数理统计就是对现实世界建立这样的一些模型跟假设，这方面的理论也算比较完善了，所以传统机器学习更能在数学理论上解释一些模型的行为。
而最近神经网络之父 Geoffrey Hinton 也表明对BP非常怀疑，应该抛弃它。BP如今是深度学习最常用的算法了，如果丢弃它，深度学习大概会大变样吧。如此看来，深度学习没有那么“完美”，仍需要大量基础研究甚至真的可能在未来被更好的算法替代。
展望未来的人工智能 如果想到三十年以后，大街小巷到处有序而不拥挤地行驶着无人车，载着乘客去景点；天空上时不时飞过一架架无人机，拍摄城市风景与监控城市安全；新闻报道是程序根据许多视频、图片。文本而撰写的；家里布满了传感器跟智能家具，许多繁琐事情可以通过简单对话跟指令来处理。 想到如果真能如此，不由对如今的人工智能算法寄予厚望并抱有乐观的想法。
但在我看来，上面的美好描述可能还是过于乐观了。
之前曾在哪里看到一个观点，20年后人工智能将会代替80%的工作。我觉得这个也太乐观了。当今现实生活中，从事脑力活动的人已经多余从事体力活动的人了，未来这个趋势应该更加明显。而以目前人工智能的能力，很多脑力活动不能代替（或者说，实现这些能代替脑力活动的程序需要更多脑力的脑力活动）。若人工智能的算法更加成熟稳定，许多人应该会从事人工智能相关的工作，建设基础设施（其实现在就有很多人往机器学习这个方向转业），普及人工智能，而只有少部分人推动人工智能的发展。
其实我一直不敢想像未来，这对于我太难了。十年前我对未来的展望似乎跟如今的现实大相径庭了。自己觉得可能出现的东西往往没有到来，反而出现一些超出以前认知的意外事物。说不定，以后深度学习也不再是实现人工智能的主力了，出现一些特定算法可以实现以前难以实现的智能，但却无法较好完成如今研究的方向。最坏的情况就是深度学习仍然是主流，而其理论仍然不明朗，调参也没有完备的方法论，人工智能发展停滞了几十年，直到我们这一代人死去，这后面的事情我也不想展望了。</description>
    </item>
    
    <item>
      <title>暑假机器学习总结</title>
      <link>/blog/posts/%E6%9A%91%E5%81%87%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 13 Sep 2017 20:49:32 +0000</pubDate>
      
      <guid>/blog/posts/%E6%9A%91%E5%81%87%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</guid>
      <description>机器学习学习总结 经过两个月的学习，从对机器学习一点点懵懂认知，到现在对机器学习的基础知识跟体系有一定的认知。如今学习暂告一段落，总结如今学习过的重点知识，可以起到很好的复习作业，也是对两个月以来的交代。以下，我将按照每周学习进度来总结回顾机器学习的知识。
第一周 我们先学习了python编程基础，之后的学习是基于python各种库来实验的。我之前已经比较熟悉python，所以很快就完成这段学习；之后接触numpy，这是C语言为python编写的底层矩阵库，我之前也接触过，但比较浅，不过numpy封装的很好，用起来门槛也很低，很快就上手了；numpy之后就是pandas,它是数据分析常用的库，基于numpy，非常全面，我之前也用过，但基本需要重新学习，pandas比较难用，尤其是IO部分，有细粒度的操作，文档看起来也比较麻烦，没有示例，所以学习的过程中，是遇到问题再去查找方法，后面的学习pandas其实用到的也比较少。
以上内容大概花了两天，算是对机器学习的预备知识的准备。当然期间也学习了简单的使用anaconda，jupyter等工具，不再一一总结了。
之后开始学习基本的图像知识：
 颜色直方图,它所描述的是不同色彩在整幅图像中所占的比例，而并不关心每种色彩所处的空间位置。之后有几次作业中要编写颜色直方图的处理，一开始还是挺棘手的。不过跟后来的图像特征提取就是小巫见大巫了 HOG特征，主要思想：在一副图像中，局部目标的表象和形状（appearance and shape）能够被梯度或边缘的方向密度分布很好地描述。（本质：梯度的统计信息，而梯度主要存在于边缘的地方）。这也是之后的需要实现的任务，学习过程中，只有这个博客资料可以参考，其他资料要么可能是全英文晦涩难懂，要么还不如这个。这个博客写的太精炼了，初学的时候，实现起来非常困难，以至于有些同学对根据这个博客写出算法的可能性产生怀疑。我这周的作业也卡在这里了，学习机器学习的时候反而是因为图像处理知识不过关。后来经过讲解对这些特征有更新的认识了，不过可能实现起来对于现在我的依然有些困难。 LBP特征、Haar特征也是这周的基础知识，我稍微学习了下LBP，发现比HOG要好懂，Haar并没有怎么看，最后这2个内容没有出现在作业里，我对这些也只有粗浅的认识。LBP（Local Binary Pattern，局部二值模式）是一种用来描述图像局部纹理特征的算子；它具有旋转不变性和灰度不变性等显著的优点。而Haar特征值反映了图像的灰度变化情况。  图像的部分内容学习后，开始了最基础的机器学习的内容：
 Regression，先从最简单的线性回归开始，线性回归可能是踏入机器学习世界的第一步吧，它教你如何做最简单的预测和机器学习比较本质的思维。前几周学习的知识大多是看李宏毅的视频，前几周感觉还是不错的。从线性回归开始，学到了基本的梯度下降思想和度量性能的代价函数。
 Error，第二节就是深入理解各种模型评估的知识，讲授了误差,偏差,方差的区别与联系。
 Gradient Descent，最后是深入学习梯度下降，学习推导基本的梯度下降，然后提出随机梯度下降(SGD)，从大量数据中随机选择一定量数据来训练，提高学习效率。除此之外，讲解了梯度下降的问题：学习率的选择。然后基于此讲解了一个算法Adagrad来控制学习率。
 最后还有一些比较杂的知识，了解了K折交叉验证的思想与作用，把数据集分割为训练集，验证集，测试集的思想与作用。各种距离度量，可以衡量样本近似度。最后完成两个作业
  图像知识可能在第一周学习，有点不知其有何用的感觉，就算想在思想上重视它，但没有实际用起来，还是难以深刻理解它的重要性吧。谈点个人感受，我其实挺不擅长也不太喜欢处理图像的，大一自己有简单接触过图像处理（跟现在的学的不太一样，而是常规的图像处理，不跟特征，知识等内容关联），虽然不比这些难，但也很吃力。
第二周 第二周主要学习的是分类的基础算法，分别学习K近邻,决策树,逻辑斯蒂回归：
 KNN的思想就是把某个样本跟其他所有样本进行距离度量并总和，该样本离哪个类别&amp;rsquo;最近&amp;rsquo;，就标记为该类别。KNN是懒惰学习的典型算法，即到需要分类的时候才使用上训练集。在学习KNN的时候还了解到矢量化编程的重要性，减少不必要的python for 循环可以利于底层numpy优化为并行代码，在我这次实验里速度提升了近百倍。
 Logistic Regression 该算法跟线性回归（跟感知器也类似）基本类似，不过它加入了sigmoid函数来进行分类而不是回归。后来学习深度学习才知道这里有神经网络的最基本的思想，或者说可能是最简单的神经网络了。
 Decision Tree决策树可能是到这周为止最难的算法了，写起来会特别长。思想其实很简单，就是树的思想 + 人类决策过程。常用的决策树有ID3,C4.5,C5.0,CART等，不过我只编写了最简单的ID3，其他决策树进行了简单的了解。学习过程中认识到如果生成完整的决策树，那会变得非常耗时，后面学习到剪枝知识（我在作业里面编写预剪枝了，不过效果很差）。学习决策树里面知道了一些信息论的知识，如信息熵,信息增益,纯度等知识，决策的依据便是依据这些数值来找到最佳决策特征。
  最后根据学到的知识完成一个井字棋胜负预测，不过我的模型很一般。这周的知识量不是很大，更多侧重机器学习基础编程，但是感觉学到东西很多的一周。
第三周 这周学习的机器学习非常强大和实用，是现在也很常用的模型：
 SVM非常理论，学到这里，我感觉我的高数白学了。其实现在我也不是很了解SVM，只对基本概念有了解。基本思想应该是把低维空间的非线性问题映射到高维空间线性问题来解决。然后里面概念非常多：支持向量的概念，距离度量，核函数，核方法，对偶问题，KKT等。
 集成学习非常实用且广用。许多一般模型集成后都可以大幅度提升性能。这周接触了许多集成学习算法：
 bagging，非常简单的集成学习算法，我后来实现了bagging决策树，性能提升了许多。基本思想是自助采样一些样本后，分别训练n个模型，然后进行投票决策。这样可以大大减少过拟合而提升性能。
 Random Forest，bagging算法的变体，基于决策树实现的。它与bagging的区别在于特化了决策树，在节点决策时，加入属性扰动（即只从一部分特征里选择最优特征），而bagging只有样本扰动（随机采集样本）。它的性能一般来说比bagging要好，我猜大概是加入了新的扰动后，更能避免决策树容易过拟合的缺点吧。
 其他如 boosting的adboost和xgboost，进行了简单了解，xgboost在kaggle里面很热门，因为性能特别好。不过这几个算法难度更大，我了解的也比较少。adboost的基本思想是让之前训练错误的部分对应的权重变大，让模型认识到这点。
  最后是一点点图像特征的知识bag of words model，对此进行一些了解
  第四周 这周学习无监督学习，主要是聚类跟降维，不过主要是侧重分析并运用这些技术：</description>
    </item>
    
    <item>
      <title>从《线性代数应该这样学》到《Redis的设计与实现》</title>
      <link>/blog/posts/%E4%BB%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%BA%94%E8%AF%A5%E8%BF%99%E6%A0%B7%E5%AD%A6%E5%88%B0redis%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Fri, 08 Sep 2017 21:50:19 +0000</pubDate>
      
      <guid>/blog/posts/%E4%BB%8E%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%BA%94%E8%AF%A5%E8%BF%99%E6%A0%B7%E5%AD%A6%E5%88%B0redis%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</guid>
      <description>从《线性代数应该这样学》到《Redis的设计与实现》 《线性代数应该这样学》 起因 这本是好早之前买的，当时想着是时候复习一下线性代数了，因为以后要用到（那时候想到可能需要接触一下机器学习了）。买来之后发现太数学了，怕是数学系的许多人也吃不消看这种书。
收获与总结 这本书可以作为第一本或者第二本线性代数的学习材料。但这本书远比本科工科的要求要高出许多，以致于作者在前言里说，这本每页应当至少投入一小时来学习。匆匆看完前两章我便放下了，书里充斥着大量证明，从最基本的向量空间的定义引出基本的性质，然后用证明的方式来引出各种向量空间的特点跟性质。而这是第一章的内容，读起来还是挺熟悉的感觉的，只是换了一种表述各种概念的方式和术语，但深入思考便与之前学习的向量没有多少差别。这里与我大一学的过程就差别大了，大一是直接从矩阵着手，最后讲到向量，但那时候觉得向量是很突兀的东西，甚至跟高中学习的向量完全不一样，没有从几何的角度稍加解释向量的一些特点。而这本书从标量开始，比较了标量跟向量的异同，开阔了一下从标量到向量的思路，本质上它们比自己想像的还要相似。
第二章接着从有限维度引申到无限维度，在讨论了无限维度的一些异同后，继续深入了向量空间的各种特性，譬如张成空间，直和这些陌生的概念。而这些与普通向量之间的联系是很紧密的，但读到后面愈发抽象，我其实也忘记了七七八八了，惭愧。
后面几章暂时就没有看了，基本应该是从向量空间引申到线性映射，然后引出矩阵及其性质。在我看来矩阵是向量空间的更一般化，所以以后继续讨论的大量性质，也可能用于向量。最后从矩阵的一般运算到各种算子，最后才提出行列式相关内容，大概就是这样（*痛苦*）的过程吧。
《TCP/IP网络编程》 感获 这本书是一本网络编程的入门书，整体难度跟CSAPP的第三部分差不多，各有侧重吧，内容有比较多重叠，但内容稍微多于CSAPP。用的是C语言的socket接口来讲解基本原理。用C语言讲有个好处，就是能直接从操作系统级别来思考网络编程，而且能使用全部的socket模式、所有并发模型、IO模型。 缺点是这些socket api相当底层，以至于一个api只做一个最基本的逻辑操作。学习起来特别费劲，而且高度依赖一部分操作系统的知识。 因为之前接触过golang和nodejs，分别也简单用过相应的socket接口。这两个语言的并发模型比较受限，nodejs目前只能异步跟简单多进程（将来应该可以用上简单多线程），golang倒是用goroutine（线程调度），通道（或者叫信道），多进程。而它们的socket接口便是跟这些模型有一定的耦合，而且高度精简，有更好的语义，从底层上面减去一些麻烦。当然，nodejs因为更单一，比golang还精简。
言归正传，这本书其实重点不在于讲解socket api，而是从使用api来达到理解socket编程思维，socket的各种核心功能，tcp/udp基本原理，并发模型的基本原理，可能还有较多的跨平台编程思路（因为C语言的socket各个系统有差异）。
一点思考 因为听说是隔壁网络工程的网络编程课的教材（说实话，这本书可能稍微浅了点，除非隔壁把这本书全部内容都讲授，我觉得才比较合理），我也无意中看到并且有打算看看。不过这本书实际比较狭窄，基本专注于tcp和并发这两个内容了，虽然充分且不错地解释了部分tcp知识，部分操作系统知识，对应用层太忽略了（提了下dns跟http），我个人认为把传输层跟应用层稍加紧密地联系起来，更能激发学习兴趣，也使这本书更加实用。
其实大概就匆匆看了半本，而且忽略了windows下的实现，自己也就琢磨了下源码，基本没有自己去写过（坏习惯啊），算是预热计算机网络跟操作系统的知识了。
《Redis的设计与实现》 这是图书馆借的到好书，其实早想看了，之前拿起来抱怨看不懂，这次再拿起来，已经不是那么可怕了。
收获 不过现在我看的比较少，数据结构篇还没有看完，也算是温习一些数据结构的知识了。这本书把redis相关的数据结构的内存模型很漂亮的表述清楚了，特别是hash和跳表，结合了许多图片来理解。也讲清楚了实现该数据结构的动机，复杂度，和一些特性。但大部分的数据结构基础操作忽略了，有些地方比较好奇，却没有讲到。这是我目前读到第六章的感受。但快开学了，这些书不太可能全看完，接下来怎么看还是得看心情咯。
最近的读书总结 其实还看了不少书，比如《深度学习》、《机器学习》、《统计学习方法》、《流畅的python》等，这些应该是一两个月前开始看的，都是需要长期学习的知识，在暑假机器学习集训班学习时来补充机器学习相关知识的。之后会写机器学习相关的总结，所以没有在这里总结一些知识跟感想。 还有部分书是跟下学期的课比较紧密的，提前看看也算是预习，本身也挺感兴趣的，也不一一列出了，读的篇幅不多，列出意义也不大。</description>
    </item>
    
    <item>
      <title>最近一周总结</title>
      <link>/blog/posts/%E6%9C%80%E8%BF%91%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 20 Aug 2017 20:57:17 +0000</pubDate>
      
      <guid>/blog/posts/%E6%9C%80%E8%BF%91%E4%B8%80%E5%91%A8%E6%80%BB%E7%BB%93/</guid>
      <description>总结 近况 杂项 发现已经漏了好几天没有写博客，也不知道自己能否坚持下去，最近可能也比较懈怠。C++的模版接触了下，发现使用还是容易掌握的，但后来就没有学下去了。靠这样学是永远学不完的，甚至学了一部分忘记七七八八了。打算下学期如果适合C++编程的任务，尽量使用C++来完成，这样有任务的使用C++应该能学的更快，更扎实，C++学好了，很多东西也都能学好，果然不是空穴来风。
兴趣方向 最近学习深度学习的基础，主要是全连接神经网络(FNN)和卷积神经网络(CNN)，其实正式学习是下周，所以这周在机器学习方面懈怠很多。其他方面呢，编译原理，《编译器设计》看了些内容，感觉很有收获，虽然不是直接关于编译原理的收获，但对计算机的全貌有了更进一步的了解。期间，查了一些关于链接的知识，也看了一点点关于linux kernel的知识，总的来说，收获了一点点学习这些知识的方法论。
英文资料 这两天买了两本英文书，打算常常读一读，一本是go圣经，一本是《编译原理与实践》。两本对于我来说应该难度不大。go圣经我看过半本中文版，虽然还掌握的不好，但有了前置知识，看英文只是时间问题。《编译原理与实践》比《龙书》跟《编译器设计》要简单些，所以买了英文版，打算下学期的编译原理课配合着读。这么说来了，在编译原理相关的书里，我已经接触了6，7本了，但其实没有精读过任何一本。下学期重点看这三本吧，以我现在半吊子的水平，希望本科基本能看完3，4本。毕竟最想从事的就是编译器相关工作，也说不清为什么偏爱这个。
不足与改正 最近越来越意识到自己在编程方面的缺陷，不论编写代码量小还是较大，自己思路一直不清晰。说来，很多我编写的代码，是根据别人的来编写的，自己完全独立从头开始写的几乎没有。上大学以后，在学业方面的作业情况也有类似，就是没有自己的思路，得照着例题来“复现”思路，但这终归不是自己学到的知识。这个问题从大学开始的，已经遗留比较久了，严重影响了自己的思维。趁着下学期的许多有趣课程跟高难度的高强度的课表，改着这个坏毛病，尽量做到把书本知识深刻映入大脑，然后根据自己的思路来完成作业而不依赖参考答案。</description>
    </item>
    
    <item>
      <title>关于未来方向学习的思考</title>
      <link>/blog/posts/%E5%85%B3%E4%BA%8E%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%80%9D%E8%80%83/</link>
      <pubDate>Fri, 11 Aug 2017 23:43:14 +0000</pubDate>
      
      <guid>/blog/posts/%E5%85%B3%E4%BA%8E%E6%9C%AA%E6%9D%A5%E6%96%B9%E5%90%91%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%80%9D%E8%80%83/</guid>
      <description>总结现状 如今 今天是周五，等会就周六了。虽然平时经常忙活在电脑前，但好像没在做什么特别有意义的事情，看到github一个好项目就想着去看它的源码，然后呢，迫于水平不够，一堆工具也掌握的不利索，怎么也没法开始学。其实大概是自己内心不知道以后到底想去做什么吧。其实2，3w行的代码如果搞懂它的流程，而且又熟悉相关语言并懂得一些相关方向的知识，应该是可以开始看了，起码不应该想到看就害怕而退缩，这连第一步都没有走呢。
想法 比较坚定的想法呢是以后做编译相关工作，这个工作岗位很少，要求也很高，许多大神高中就开始接触了。我呢，现在还半吊子，最近才开始理解了最基本的知识，将来如果要考研，这应该是计算机体系结构这个方向的研究生吧。而这2个月一直在学机器学习，但我只是对它的原理好奇，又想着机器学习方向能跟数学打交道，又能锻炼算法能力，便很欣然地参加了这次暑假集训。最近这个月有些忙坏了，但又觉得自己学到知识很少，可能是太贪心了吧，自己对计算机许多方向都感兴趣，但未曾深入其中一个。我还经常跟同学说那句话：不要总想着以后要干嘛，你现在在干嘛，以后很可能就在干嘛，所以要干嘛就赶紧现在就开始干。其实我自己也没有做到我所说，虽然我非常希望自己能做到。
兴趣 最近查阅了一些资料，其实都是自己以前都看过，只是很多不少都忘记了或者没有重视起来。记得大一时候对C++兴趣特别浓厚，买了C++primer和STL源码剖析，还很认真看过（但没怎么敲代码），后来接触了的其他编程语言，C++也基本没有使用过了。现在要是还记得大一C++要求的内容就不错咯。
但我知识，我想以后从事的方向很可能离不开C++（至少10年是这样）。不论是机器学习或者是编译原理，还是网络编程，在高性能的场合，永远需要它。
目前我比较感兴趣的是编译原理，机器学习，网络编程吧。 这三个都可以学很深，无底洞。编译原理简单的话，写个编译器前端，嗯，可能还不如自动化工具强，学的深入了，就得学后端了，代码优化，无底洞，国内好像没几家公司需要这种人才（大概更不需要应届生吧）。不过作为“永不失业的职业”，我对编译原理里面的设计成分更感兴趣，即自制语言。而如果作为一个应用开发者的话，约束应该大很多了，很多时候公式让你做的跟你的兴趣点完全无关，再考虑国内公司的尿性，不让你干缺德的就不错了。
扯远了，关于“设计”这种概念，对于机器学习跟网络编程，也同样适用吧。机器学习重在解决问题，而设计算法是重要环节，这里设计部分可能要发挥脑力，而不是跟风地调用算法，我觉得这里也是很有意思的部分，但如果是解决商业问题，或者做项目的话，自由度感觉不大，倒是留在实验室研究什么的更有意思（虽然最近就是留实验室学习，有点小枯燥）。而网络编程，重点是在网络层以上的开发，打交道是传输层跟应用层，设计协议是很有意思的一环。怎么样的协议更有语义，更高效，更安全，扩展性强，我觉得这部分自制性很强，也是很有研究的感觉。
隐隐约约觉得以上三个方向深入研究最后都要跟并发或性能打交道。毫无疑问，编译原理，优化部分，可能需要把代码隐式转换为并发代码，或者编译成适合并发的机器代码。机器学习虽然是高阶算法，但依托于大数据平台，而底层需要高并发，分布式的架构。有时候算法策略本身可能需要考虑容易并发，而如果设计一个机器学习平台或者系统，底层模型肯定到处是并发，也明显需要分布式。网络编程呢，则是为了更好的进行数据交换，也是并发的策略之一，更是分布式计算的基石。
以上三个方向，在底层方面最需要的便是C++了。众所周知C++是比较难掌握的，虽然现在情况在变好，但我其实还蛮担心自己毕业前连基本的STL都用不好。
基本规划 好像写了这么多，还是不清楚接下来应该如何去学习知识，在这最后的2年时间。其实下个学期课挺多的，而且都是比较难的课，虽然大部分我都挺感兴趣的，但精力一旦不足，我容易对计算机感到一种疲惫，然后几天不碰。而下个学期如此多的课的情况，在学好课内之余如何把课外感兴趣的知识补上呢（C++，机器学习，网络编程深入学习）。可能就只能在周末多抽出时间学习了吧。 算上准备考研，也该多用用C++了，这样数据结构也算复习了。而下学期部分课需要一些数学知识，正好稍微注重一下复习数学，也算事半功倍了。网络编程这部分，即使只是简单地学习，对计算机网络这门课帮助也不少啊，感觉咬咬牙，下学期真的能学到很多知识吧，只希望自己不要自暴自弃，要善于总结学到的知识。
如此一想，感觉也想通了一些，毕竟学习编译原理，计算机网络，操作系统的时候是完全可以用C++来实现相应的功能的，这也锻炼了我C++的水平，但可能目前完全达不到吧，所以打算暑假稍微学习一下C++。
嗯，决定了，暑假还剩一个月，我打算学习以下内容：
 机器学习跟深度学习，这部分跟实验室进度来，尽量不落下吧 C++，看些简单的源码，学习一下STL，把忘记的捡起来 简单的编译原理学习，实现几个简单的玩具编译器（已经跟着博客抄了一个，感觉还需要再写一个），如果可能的话，用C++来实现 网络编程，这一块，估计很麻烦，我基本没有实战过，倒是有基本的理论知识，理想情况下应该是golang或者nodejs来写（它们封装的很好，写起来难度容易接受），C++写的话，估计写一个月也写不出什么。所以尽量暑假尝试写个简单协议（突然想起来之前写redgo，有机会完善下）  其实对C++一向是又爱又恨，爱是觉得这门语言太重要了，感觉如果掌握，用其他语言也就游刃有余了，而且有些语法感觉真的很厉害。恨是觉得这门语言太复杂了，我掌握很吃力，而且有些语法根本就是坑，基础设施STL也是非常复杂。写项目的话，我连相应的流程，工具，环境都不了解。
现在已经周六了，大概就写到这里了，其实我也是编写边梳理自己的思路。 写出来呢，可以经常看，这样自己就不会忘记对自己的严格要求了。每次面对电脑，2小时也不做点有意义的事情的时候，你就会觉得自己真是非常没用，那句话怎么说来着：回首过去，尽是些可耻往事。
大概不论爱好什么，最简单证明自己的热情，是不留余力地享受自己的爱好吧</description>
    </item>
    
    <item>
      <title>机器学习里的一些小概念</title>
      <link>/blog/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%87%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Thu, 10 Aug 2017 13:53:56 +0000</pubDate>
      
      <guid>/blog/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%87%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%A6%82%E5%BF%B5/</guid>
      <description> 机器学习里的一些小概念 轮廓系数 轮廓系数（Silhouette Coefficient），是聚类效果好坏的一种评价方式。最早由 Peter J. Rousseeuw 在 1986 提出。 它结合内聚度和分离度两种因素。可以用来在相同原始数据的基础上用来评价不同算法、或者算法不同运行方式对聚类结果所产生的影响。
计算过程 假设我们已经通过一定算法，将待分类数据进行了聚类。 常用的比如使用K-means，将待分类数据分为了k个簇。 对于簇中的每个向量。分别计算它们的轮廓系数。 对于其中的一个点 i 来说：
 计算 a(i) = average(i向量到所有它属于的簇中其它点的距离) 计算 b(i) = min(i向量到所有其他簇的点的平均距离)  那么i向量轮廓系数就为： {% raw %} $$ S(i) = \frac{b(i) - a(i)}{max{a(i), b(i)}} $$ {% endraw %}
判断 可见轮廓系数的值是介于 [-1,1] ，越趋近于1代表内聚度和分离度都相对较优。将所有点的轮廓系数求平均，就是该聚类结果总的轮廓系数。
 a(i) ：i向量到同一簇内其他点不相似程度的平均值 b(i) ：i向量到其他簇的平均不相似程度的最小值 S(i)接近1，则说明样本i聚类合理； S(i)接近-1，则说明样本i更应该分类到另外的簇； 若S(i)近似为0，则说明样本i在两个簇的边界上。  未完待续 </description>
    </item>
    
    <item>
      <title>k-means</title>
      <link>/blog/posts/k-means/</link>
      <pubDate>Tue, 08 Aug 2017 16:18:09 +0000</pubDate>
      
      <guid>/blog/posts/k-means/</guid>
      <description>公式排版目前没法解决唉，博客写个数学公式怎么这么揪心，好不容易解决了公式显示问题，但排版又很难控制
k-means 基本原理 这个星期学无监督学习(unsuperviser-learning), 最基本的是k-means算法. k-means属于原型聚类:假设聚类结构能通过一组原型刻画. 而聚类本身是根据数据相似度来划分的,即&amp;rdquo;距离&amp;rdquo;.我这里不展开讲距离计算, 姑且用欧几里德距离来理解，即平时最常见的公式. {% raw %}
我们先写出k-means的最小化平方误差: 给定样本集合 $D = {x_1, x_2, \dots, x_m}$,
k-means对聚类所得的簇划分 $C = {C_1, C_2, \dots, Ck}$ 的最小平方误差是 $E = \sum{i=1}^k \sum_{x \in C_i} ||x - \mu_i||_2^2 $,
其中 $\mu_i = \frac{1}{|Ci|} \sum{x \in C_i}x$是簇$ C_i $ 的均值向量 {% endraw %}
可以看出来, 求该式子的最优解并不容易, 因为需要考察每个样本可能的划分情况(NP难问题), 所以k-means 采用贪心策略, 通过迭代优化求近似解.
感觉学完以上内容, 脑子里好像有了这个算法的轮廓了, 但仔细一想, 还有很多地方需要斟酌. k-means是划分为k个类别, 那一开始怎么划分呢? 我们想到一开始需要选k个样本当作中心点来计算距离, 根据这k个位置就求得每个样本离哪个位置最接近. 这样,第一次聚类就完成了, 但是由于这次聚类造成每个类别的中心点发生了偏移,
我们需要重新计算这时候的中心点,而由于发生了偏移,我们又需要重新计算所有样本最接近的&amp;hellip; 如何反复,直到中心点(即均值向量)不变, 便完成了聚类.</description>
    </item>
    
    <item>
      <title>《Web API的设计与开发》读书笔记</title>
      <link>/blog/posts/web-api%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 08 Aug 2017 12:11:10 +0000</pubDate>
      
      <guid>/blog/posts/web-api%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description> 第1章 什么是 Web API Web API 的重要性 一些在线服务能够对那些公开的API进行会话控制、访问控制、服务分析，提供面向用户的仪表盘，以及发布文档等，承接了各种各样的工作。
通过对外公开 Web API，同外部其他服务的集成变得更加便捷，并从中衍生出了新的价值，使在线服务以及业务不断发展，逐步形成了“API经济学”的景象，并在这几年受到相当大的关注。
各种各样的 API 模式  将已发布的 Web 在线服务的数据或功能通过 API 公开 将附加在其他网页上的微件公开 构建现代 Web 应用 开发智能手机应用 公司内部多个系统的集成  应该通过 API 公开什么  最简洁的答案是将你的在线服务所能做的事情全部通过API公开 不存在彻底屏蔽搜集信息的行为，所以无需担心盗用，公开 API并不意味着毫无限制的访问 公开 API 将原来的服务组合成新的应用来为用户提供服务的“间接销售”模式  设计优美 API 的重要性  易于使用 便于更改 健壮性好 不怕公之于众  如何美化 Web API 两个重要原则：
 设计规范明确的内容必须遵守相关规范 没有设计规范的内容必须遵守相关事实标准  REST 与 Web API REST 依次一般指下面两种意思：
 符合 Fielding 的 REST 架构风格的Web服务系统 符合 RPC风格的 XML (或JSON) + HTTP 接口的系统(不使用SOAP)  小结  如果尚未公开 Web AP，则应立即考虑公开 设计优美的 Web API 不用过分拘泥于 REST 一词  </description>
    </item>
    
    <item>
      <title>欢迎，刚搭建好的博客</title>
      <link>/blog/posts/%E6%AC%A2%E8%BF%8E%E5%88%9A%E6%90%AD%E5%BB%BA%E5%A5%BD%E7%9A%84%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Tue, 08 Aug 2017 09:11:10 +0000</pubDate>
      
      <guid>/blog/posts/%E6%AC%A2%E8%BF%8E%E5%88%9A%E6%90%AD%E5%BB%BA%E5%A5%BD%E7%9A%84%E5%8D%9A%E5%AE%A2/</guid>
      <description>分享知识与见解 博客搭建的过程 照理说用hexo搭建博客是一分钟的事情，结果我花了6小时，其中绝大部分时间花在了主题上面，想找个能写数学公式的主题不容易啊，又要符合自己的审美，而且文档要齐全没有bug。 最后找到了这个，但是文档还是不够详解，有些功能不知道如何使用，但暂且将就下吧。这个主题自带了mathjax，不过我还没有测试过能不能写公式，我现在就来测试
$ (\frac{1}{2})^2 = \frac{1}{4} $
顺便测试下代码效果吧
class Person{ constructor(name, age){ this.name = name this.age = age } } let person = new Person(&#39;yjh&#39;, 20)  我把这个博客发了一下，看见真的可以写公式了，很开心，但这6个小时的苦大概是说不清了，而现在已经9点多了，我应该要继续学习无监督学习了。暂且这样吧，回去再折腾折腾，现在赶紧发个url给同学来测试下效果吧！</description>
    </item>
    
  </channel>
</rss>